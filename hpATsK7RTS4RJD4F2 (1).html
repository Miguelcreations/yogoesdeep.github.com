<html><head><base href="." /><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Zombie Defense X</title><style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    overflow: hidden;
    background: #1a1a1a;
    font-family: 'Courier New', monospace;
    color: #0f0;
}
html {
    overflow: hidden;
}

#gameContainer {
    display: flex;
    width: 100vw;
    height: 100vh;
}

#gameBoard {
    flex: 3;
    background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23203020"/><path d="M0 50h100M50 0v100" stroke="%23304030" stroke-width="1"/></svg>');
    position: relative;
    overflow: hidden;
}

#shop {
    flex: 1;
    background: #2a2a2a;
    padding: 20px;
    overflow-y: auto;
    max-width: 300px;
    height: 100vh;
}

.tower-option {
    background: #333;
    margin: 10px 0;
    padding: 10px;
    border: 2px solid #0f0;
    cursor: pointer;
    transition: 0.3s;
}

.tower-option:hover {
    background: #444;
    transform: scale(1.02);
}

.tower, .zombie {
    position: relative;
}

.zombie-health-bar {
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 3px;
    background: #333;
    border: 1px solid #000;
}

.zombie-health-fill {
    height: 100%;
    width: 100%;
    background: #f00;
    transition: width 0.2s;
}

.tower:hover::after, .zombie:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    background: rgba(0,0,0,0.8);
    color: #0f0;
    padding: 5px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1000;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
}

.tower {
    position: absolute;
    width: 40px;
    height: 40px;
    transform: translate(-50%, -50%);
    display: flex;
    justify-content: center;
    align-items: center;
}

.tower::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: currentColor;
    clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
}

.tower::after {
    content: '';
    position: absolute;
    width: 60%;
    height: 60%;
    background: rgba(255,255,255,0.2);
    border-radius: 50%;
}

.zombie {
    position: absolute;
    width: 30px;
    height: 30px;
    transform: translate(-50%, -50%);
    display: flex;
    justify-content: center;
    align-items: center;
}

.zombie::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: currentColor;
    clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
    animation: wobble 0.5s ease-in-out infinite alternate;
}

.zombie::after {
    content: '';
    position: absolute;
    width: 60%;
    height: 60%;
    top: 20%;
    left: 20%;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

.zombie[data-type="normal"]::after {
    background: radial-gradient(circle, transparent 30%, #3f3 70%);
}

.zombie[data-type="fast"]::after {
    content: '‚ö°';
    color: yellow;
}

.zombie[data-type="tank"]::after {
    content: 'üî•';
    color: red;
}

.zombie[data-type="boss"]::after {
    clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    background: #f0f;
    transform: translateY(-50%);
}

.zombie[data-type="necromancer"]::after {
    content: 'üíÄ';
}

.zombie[data-type="splitting"]::after {
    background: repeating-linear-gradient(45deg, #fa0, #fa0 5px, transparent 5px, transparent 10px);
}

.zombie[data-type="teleporter"]::after {
    background: radial-gradient(circle, #0ff 30%, transparent 70%);
    animation: pulse 1s infinite;
}

.zombie[data-type="absorber"]::after {
    background: conic-gradient(from 0deg, #f7f 0%, transparent 100%);
    animation: rotate 2s linear infinite;
}

.zombie[data-type="crystalline"]::after {
    clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
    background: linear-gradient(45deg, #fff, transparent);
}

.zombie[data-type="meteor"]::after {
    background: radial-gradient(circle, #f00, #800);
}

.zombie[data-type="ghost"]::after {
    background: rgba(136, 136, 255, 0.5);
}

@keyframes wobble {
    from { transform: rotate(-5deg); }
    to { transform: rotate(5deg); }
}

#resources {
    position: fixed;
    top: 10px;
    left: 10px;
    font-size: 24px;
    color: #0f0;
    text-shadow: 2px 2px #000;
    z-index: 1001;
}

.projectile {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #ff0;
    border-radius: 50%;
    transform: translate(-50%, -50%);
}

.projectile[data-type="missile"] {
    background: #f44 !important;
    width: 20px !important;
    height: 20px !important;
    border-radius: 50%;
    animation: missileArc 1s linear;
}

@keyframes missileArc {
    0% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(0.2); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

.projectile.crystal-shard {
    background: linear-gradient(45deg, #aaf, #fff) !important;
    clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%) !important;
}

.range-indicator {
    position: absolute;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    pointer-events: none;
    transform: translate(-50%, -50%);
    z-index: 100;
}

.effect-indicator {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    opacity: 0.3;
    z-index: 1;
}

.poison-indicator { 
    background: rgba(0, 255, 0, 0.2);
    border: 2px solid #0f0;
}

.button-container {
    padding: 10px;
    background: #2a2a2a;
    height: 30vh;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#glossaryButton, #changelogButton, #pauseButton, #restartButton, #fastForwardBtn {
    position: fixed;
    top: 10px;
    background: rgba(42, 42, 42, 0.7);
    border: 2px solid rgba(0, 255, 0, 0.7);
    color: #0f0;
    cursor: pointer;
    padding: 5px 15px;
    margin: 0;
    z-index: 100;
}

#glossaryButton { right: 320px; }
#changelogButton { right: 440px; }
#pauseButton { right: 560px; }
#restartButton { right: 680px; }
#fastForwardBtn { right: 800px; }

#playerCount {
    position: fixed;
    bottom: 10px;
    right: 320px;
    background: rgba(42, 42, 42, 0.7);
    color: #0f0;
    padding: 5px 15px;
    border: 2px solid rgba(0, 255, 0, 0.7);
    z-index: 1000;
}

.poison-effect {
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
}

.poison-counter {
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    color: #0f0;
    font-size: 12px;
    text-shadow: 1px 1px 1px black;
}

.victory-confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    pointer-events: none;
    z-index: 9999;
    animation: fall 3s linear forwards;
}

@keyframes fall {
    to {
        transform: translateY(100vh) rotate(360deg);
    }
}

#glossary, #changelog, #reviewDialog {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(42, 42, 42, 0.9);
    border: 2px solid #0f0;
    padding: 20px;
    color: #0f0;
    z-index: 1001;
    max-height: 80vh;
    overflow-y: auto;
    width: 80%;
    max-width: 800px;
}

#reviewDialog {
    z-index: 10000;
}

#changelog .changelog-nav {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
}

.changelog-page {
    display: none;
}

.changelog-page.active {
    display: block;
}

#mainMenu {
    position: fixed;
    top: 0; 
    left: 0; 
    width: 100vw; 
    height: 100vh; 
    background: rgba(0,0,0,0.9); 
    z-index: 9999; 
    display: flex; 
    flex-direction: column; 
    justify-content: center; 
    align-items: center; 
    color: #0f0;
}

#mainMenu h1 {
    font-size: 48px; 
    margin-bottom: 40px;
}

#mainMenu button {
    font-size: 24px; 
    padding: 15px 30px; 
    background: #2a2a2a; 
    border: 2px solid #0f0; 
    color: #0f0; 
    cursor: pointer; 
    margin: 10px;
}

.meteor-boss {
    width: 60px !important;
    height: 60px !important;
    background: radial-gradient(circle, #f00, #800) !important;
}

.meteor-projectile {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #f00;
    border-radius: 50%;
    filter: drop-shadow(0 0 10px #f00);
}

.tower-stunned {
    filter: grayscale(100%) brightness(50%);
    pointer-events: none;
}

#debugButton {
    position: fixed;
    bottom: 40px;
    right: 320px;
    background: rgba(42, 42, 42, 0.3);
    border: 1px solid rgba(0, 255, 0, 0.3);
    color: #0f0;
    font-size: 10px;
    padding: 2px 5px;
    cursor: pointer;
    z-index: 1000;
}

#debugPanel {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(42, 42, 42, 0.9);
    border: 2px solid #0f0;
    padding: 10px;
    color: #0f0;
    z-index: 1001;
    width: 200px;
}

.debug-button {
    width: 100%;
    margin: 5px 0;
    background: #2a2a2a;
    border: 1px solid #0f0;
    color: #0f0;
    padding: 5px;
    cursor: pointer;
}

.stats-container {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #0f0;
}

.review {
    background: #333;
    margin: 10px 0;
    padding: 10px;
    border: 1px solid #0f0;
}

.votes {
    margin-top: 5px;
}

.votes button {
    background: #2a2a2a;
    border: 1px solid #0f0;
    color: #0f0;
    padding: 2px 5px;
    margin-right: 5px;
    cursor: pointer;
}

.votes button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.tesla-chain {
    background: rgba(255, 255, 0, 0.2);
    border: 2px solid #ff0;
    animation: chain-flash 0.2s linear;
}

.lightning-bolt {
    position: absolute;
    height: 4px;
    transform-origin: left center;
    pointer-events: none;
    z-index: 1000;
}

.lightning-core {
    position: absolute;
    width: 100%;
    height: 100%;
    background: #ff0;
    clip-path: polygon(
        0 0, 15% 50%, 30% 0, 45% 50%,
        60% 0, 75% 50%, 90% 0, 100% 50%,
        90% 100%, 75% 50%, 60% 100%, 45% 50%,
        30% 100%, 15% 50%, 0 100%
    );
    animation: lightning-flash 0.2s linear;
}

.lightning-shadow {
    position: absolute;
    width: 100%;
    height: 200%;
    top: -50%;
    background: #000;
    clip-path: polygon(
        0 25%, 15% 50%, 30% 25%, 45% 50%,
        60% 25%, 75% 50%, 90% 25%, 100% 50%,
        90% 75%, 75% 50%, 60% 75%, 45% 50%,
        30% 75%, 15% 50%, 0 75%
    );
    opacity: 0.3;
    filter: blur(1px);
}

@keyframes lightning-flash {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 0; }
}
</style></head><body>
<div id="mainMenu" style="display: flex;">
    <h1>Zombie Defense X</h1>
    <button id="startGameBtn">Start Game</button>
    <button id="howToPlayBtn">How to Play</button>
    <button id="reviewBtn">Reviews</button>
</div>
<div id="gameContainer" style="display: none;">
    <div id="gameBoard"></div>
    <div id="shop">
        <h2>DEFENSE TOWERS</h2>
        <div class="tower-option" data-type="basic" data-cost="100">
            Basic Tower ($100)<br>
            <small>Simple but reliable</small>
        </div>
        <div class="tower-option" data-type="sniper" data-cost="200">
            Sniper Tower ($200)<br>
            <small>Long range, high damage</small>
        </div>
        <div class="tower-option" data-type="crystal" data-cost="300">
            Crystal Shard Tower ($300)<br>
            <small>Short range burst damage</small>
        </div>
        <div class="tower-option" data-type="tesla" data-cost="650">
            Tesla Tower ($650)<br>
            <small>Chain lightning damage</small>
        </div>
        <div class="tower-option" data-type="flame" data-cost="350">
            Flame Tower ($350)<br>
            <small>Continuous damage over time</small>
        </div>
        <div class="tower-option" data-type="missile" data-cost="800">
            Missile Silo Tower ($800)<br>
            <small>Explosive area damage</small>
        </div>
        <div class="tower-option" data-type="ice" data-cost="300">
            Ice Tower ($300)<br>
            <small>Slows zombies</small>
        </div>
        <div class="tower-option" data-type="poison" data-cost="500">
            Poison Tower ($500)<br>
            <small>Damage over time</small>
        </div>
    </div>
</div>
<div class="button-container">
    <button id="glossaryButton">Glossary</button>
    <button id="changelogButton">Changelog</button>
    <button id="pauseButton">Pause</button>
    <button id="restartButton">Restart Game</button>
    <button id="fastForwardBtn">Fast Forward Wave</button>
</div>
<div id="resources">Money: $<span id="money">600</span> | Wave: <span id="wave">0</span> | Health: <span id="health">100</span></div>
<div id="playerCount">Players Online: <span id="playerCountNum">1</span></div>
<button id="debugButton">üîß</button>
<div id="debugPanel">
    <button class="debug-button" id="skipWaveBtn">Skip Wave</button>
    <button class="debug-button" id="addMoneyBtn">Add $50,000</button>
    <button class="debug-button" id="godModeBtn">God Mode: OFF</button>
    <div class="stats-container">
        <div>Unique Players: <span id="uniquePlayers">0</span></div>
        <div>Boss Defeats: <span id="bossDefeats">0</span></div>
    </div>
</div>
<div id="glossary">
    <div class="close-button">X</div>
    <h2>Zombie Glossary</h2>
    <div id="glossaryContent"></div>
</div>
<div id="changelog" style="display:none">
    <div class="close-button">X</div>
    <h2>Changelog</h2>
    <div class="changelog-nav">
        <button class="prev-page">Previous</button>
        <span class="page-indicator">Page 1/3</span>
        <button class="next-page">Next</button>
    </div>
    <div class="changelog-pages">
        <div class="changelog-page active" data-page="1">
            <div class="changelog-entry">
                <h3>Update v1.8: "Ghost & Balance"</h3>
                <ul>
                    <li>Added health bars to all zombies</li>
                    <li>Increased basic tower damage to 45</li>
                    <li>Added Ghost Zombie type</li>
                    <li>Fixed missile silo targeting</li>
                    <li>Improved tower targeting priorities</li>
                </ul>
            </div>
            <div class="changelog-entry">
                <h3>Update v1.7: "Chain Lightning Evolution"</h3>
                <ul>
                    <li>Rebalanced Tesla Tower chain lightning system</li>
                    <li>Optimized Crystal Shard Tower performance</li>
                    <li>Added distance-based cleanup for crystal shards</li>
                    <li>Fixed potential memory leaks</li>
                    <li>Added proper chain damage scaling</li>
                </ul>
            </div>
        </div>
        <div class="changelog-page" data-page="2">
            <div class="changelog-entry">
                <h3>Update v1.6: "Crystal Evolution"</h3>
                <ul>
                    <li>Removed shotgun tower</li>
                    <li>Added new Crystal Shard Tower</li>
                    <li>Fixed player counter positioning</li>
                    <li>Added crystal shard damage system</li>
                </ul>
            </div>
        </div>
        <div class="changelog-page" data-page="3">
            <div class="changelog-entry">
                <h3>Update v1.5: "The Defense Revolution"</h3>
                <ul>
                    <li>Added player count system</li>
                    <li>Fixed shotgun and basic tower damage</li>
                    <li>Increased starting money to $600</li>
                    <li>Added restart game functionality</li>
                </ul>
            </div>
        </div>
    </div>
</div>
<div id="reviewDialog">
    <div class="close-button" style="float: right; cursor: pointer;">X</div>
    <h2>Player Reviews</h2>
    <div id="reviewList"></div>
    <textarea id="newReview" placeholder="Write your review..." style="width: 300px; height: 100px; margin: 10px 0;
              background: #333; color: #0f0; border: 1px solid #0f0;"></textarea>
    <button id="submitReview">Submit Review</button>
</div>
<script>
class Game {
    constructor() {
        this.room = new WebsimSocket();
        this.debugMode = false;
        this.godMode = false;
        this.fastForwardedCount = 0; 
        
        if (localStorage.getItem('debugEnabled') === 'true') {
            document.getElementById('debugButton').style.display = 'block';
        } else {
            document.getElementById('debugButton').style.display = 'none';
        }

        this.debugCode = '';
        document.addEventListener('keydown', (e) => {
            this.debugCode += e.key.toUpperCase();
            if (this.debugCode.includes('MANAGER ESQUIRE')) {
                document.getElementById('debugButton').style.display = 'block';
                localStorage.setItem('debugEnabled', 'true');
            }
            if (this.debugCode.length > 20) {
                this.debugCode = this.debugCode.slice(-20);
            }
        });
        
        this.setupStatTracking();

        const playerId = localStorage.getItem('playerId') || crypto.randomUUID();
        localStorage.setItem('playerId', playerId);
        
        document.getElementById('startGameBtn').addEventListener('click', () => {
            if (!localStorage.getItem('hasPlayed')) {
                this.room.store.update({
                    id: 'playerStats',
                    dependencies: {},
                    updateFunction: (stats) => ({
                        ...stats,
                        uniquePlayers: stats.uniquePlayers + 1
                    })
                });
                localStorage.setItem('hasPlayed', 'true');
            }
        });

        this.recentlyDeadZombies = [];
        this.zombieNames = {
            normal: "Normal Zombie",
            fast: "Speed Zombie", 
            tank: "Tank Zombie",
            boss: "Boss Zombie",
            necromancer: "Necromancer Zombie",
            splitting: "Splitting Zombie",
            teleporter: "Teleporter Zombie",
            absorber: "Absorber Zombie",
            crystalline: "Crystalline Zombie",
            meteor: "Meteor Zombie",
            ghost: "Ghost Zombie"
        };
        document.getElementById('startGameBtn').addEventListener('click', () => {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            this.money = 600;
            this.wave = 0; 
            this.health = 100;
            this.zombies = [];
            this.towers = [];
            this.projectiles = [];
            this.crystalBarriers = [];
            this.lastUpdate = Date.now();
            this.spawnZombieTimer = 0;
            this.zombiesInWave = 10;
            this.zombiesSpawned = 0;
            this.waveInProgress = false;
            this.paused = false;
            this.updateResources();
        });
        
        document.getElementById('howToPlayBtn').addEventListener('click', () => {
            alert('Place towers strategically to defend against waves of zombies!\n\nEach tower has unique abilities and costs.\n\nSurvive as many waves as possible!');
        });

        this.towers = [];
        this.zombies = [];
        this.projectiles = [];
        this.crystalBarriers = [];
        this.gameBoard = document.getElementById('gameBoard');
        this.setupEventListeners();
        this.setupPlayerCount();
        this.lastUpdate = Date.now();
        this.spawnZombieTimer = 0;
        this.zombiesInWave = 10; 
        this.zombiesSpawned = 0;
        this.waveInProgress = false;
        this.paused = false;
        this.zombieTypes = ['normal', 'fast', 'tank', 'boss', 'necromancer', 'splitting', 'teleporter', 'absorber', 'crystalline'];
        this.zombieKills = {
            normal: 0,
            fast: 0,
            tank: 0,
            boss: 0,
            necromancer: 0,
            splitting: 0,
            teleporter: 0,
            absorber: 0,
            crystalline: 0,
        };
        this.zombieInfo = {
            normal: {
                name: "Normal Zombie",
                description: "Basic undead creature. Slow but steady.",
                health: 100,
                speed: "Normal",
                special: "None",
                firstWave: 1
            },
            fast: {
                name: "Speed Zombie",
                description: "Quick but fragile zombie that can overwhelm defenses.",
                health: 75,
                speed: "Fast",
                special: "2x Movement Speed",
                firstWave: 1
            },
            tank: {
                name: "Tank Zombie",
                description: "Heavily armored zombie that explodes on death.",
                health: 300,
                speed: "Slow",
                special: "Explodes on death, destroying nearby towers",
                firstWave: 3
            },
            boss: {
                name: "Boss Zombie",
                description: "Powerful leader that shields nearby zombies.",
                health: 1000,
                speed: "Very Slow",
                special: "Generates protective shield for nearby zombies",
                firstWave: 5
            },
            necromancer: {
                name: "Necromancer Zombie",
                description: "Revives nearby fallen zombies.",
                health: 200,
                speed: "Slow",
                special: "Resurrects defeated zombies",
                firstWave: 6
            },
            splitting: {
                name: "Splitting Zombie",
                description: "Splits into two smaller zombies when killed. Green-orange hue with pulsing effect.",
                health: 150,
                speed: "Normal",
                special: "Creates two mini-zombies on death",
                firstWave: 7
            },
            teleporter: {
                name: "Teleporter Zombie",
                description: "Glowing cyan zombie that phases in and out. Short-range teleports.",
                health: 120,
                speed: "Normal", 
                special: "Occasionally blinks forward",
                firstWave: 8
            },
            absorber: {
                name: "Absorber Zombie",
                description: "Pinkish-purple zombie that grows larger as allies die nearby.",
                health: 180,
                speed: "Normal",
                special: "Gets stronger as allies die",
                firstWave: 9
            },
            crystalline: {
                name: "Crystalline Zombie",
                description: "Translucent white zombie covered in sharp crystals.",
                health: 400,
                speed: "Slow",
                special: "Reflects 30% of damage",
                firstWave: 10
            }
        };
        this.zombieSounds = {
            normal: this.createSafeAudio('groan.mp3'),
            fast: this.createSafeAudio('screech.mp3'),
            tank: this.createSafeAudio('roar.mp3'),
            boss: this.createSafeAudio('bellow.mp3'),
            necromancer: this.createSafeAudio('necromancer.mp3'),
            splitting: this.createSafeAudio('splitting.mp3'),
            teleporter: this.createSafeAudio('teleporter.mp3'),
            absorber: this.createSafeAudio('absorber.mp3'),
            crystalline: this.createSafeAudio('crystalline.mp3'),
        };
        this.setupReviewSystem();
        this.gameLoop();

        this.room.onRecordChanged = (id) => {
            if (id === 'playerStats') {
                this.room.store.get('playerStats').then(stats => {
                    document.getElementById('uniquePlayers').textContent = stats.uniquePlayers;
                    document.getElementById('bossDefeats').textContent = stats.bossDefeats;
                });
            }
            if (id === 'reviews') {
                if (document.getElementById('reviewDialog').style.display === 'block') {
                    this.updateReviewList();
                }
            }
        };
    }

    updateResources() {
        document.getElementById('money').textContent = this.money;
        document.getElementById('wave').textContent = this.wave;
        document.getElementById('health').textContent = this.health;
    }

    setupStatTracking() {
        this.room.store.get('playerStats').then(stats => {
            if (!stats) {
                this.room.store.update({
                    id: 'playerStats',
                    dependencies: {},
                    updateFunction: () => ({
                        uniquePlayers: 0,
                        bossDefeats: 0
                    })
                });
            }
        });

        this.room.onRecordChanged = (id) => {
            if (id === 'playerStats') {
                this.room.store.get('playerStats').then(stats => {
                    document.getElementById('uniquePlayers').textContent = stats.uniquePlayers;
                    document.getElementById('bossDefeats').textContent = stats.bossDefeats;
                });
            }
        };
    }

    setupReviewSystem() {
        const reviewBtn = document.getElementById('reviewBtn');
        const reviewDialog = document.getElementById('reviewDialog');
        const submitBtn = document.getElementById('submitReview');

        reviewBtn.addEventListener('click', () => {
            reviewDialog.style.display = 'block';
            this.updateReviewList();
        });

        submitBtn.addEventListener('click', () => {
            const text = document.getElementById('newReview').value;
            if (text.trim()) {
                this.room.store.update({
                    id: 'reviews',
                    dependencies: { 
                        text,
                        username: this.room.party.client.username,
                        clientId: this.room.party.client.id
                    },
                    updateFunction: (reviews = []) => [
                        ...reviews,
                        {
                            id: Date.now(),
                            text,
                            username,
                            clientId,
                            votes: { up: 0, down: 0 },
                            voters: {}
                        }
                    ]
                });
                document.getElementById('newReview').value = '';
                this.updateReviewList();
            }
        });

        const closeBtn = document.querySelector('#reviewDialog .close-button');
        closeBtn.addEventListener('click', () => {
            document.getElementById('reviewDialog').style.display = 'none';
        });
    }

    updateReviewList() {
        const list = document.getElementById('reviewList');
        this.room.store.get('reviews').then(reviews => {
            if (!reviews) return;
            
            list.innerHTML = reviews.map(review => `
                <div class="review" data-id="${review.id}">
                    <p>${review.text}</p>
                    <small>by ${review.username}</small>
                    <div class="votes">
                        <button class="vote-up" ${review.voters[this.room.party.client.id] ? 'disabled' : ''}>
                            üëç ${review.votes.up}
                        </button>
                        <button class="vote-down" ${review.voters[this.room.party.client.id] ? 'disabled' : ''}>
                            üëé ${review.votes.down}
                        </button>
                        ${review.clientId === this.room.party.client.id ? 
                            '<button class="delete-review">‚ùå</button>' : ''}
                    </div>
                </div>
            `).join('');

            list.querySelectorAll('.vote-up, .vote-down').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const reviewId = parseInt(e.target.closest('.review').dataset.id);
                    const isUpvote = e.target.classList.contains('vote-up');
                    this.voteReview(reviewId, isUpvote);
                });
            });

            list.querySelectorAll('.delete-review').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const reviewId = parseInt(e.target.closest('.review').dataset.id);
                    this.deleteReview(reviewId);
                });
            });
        });
    }

    voteReview(reviewId, isUpvote) {
        this.room.store.update({
            id: 'reviews',
            dependencies: { reviewId, isUpvote, clientId: this.room.party.client.id },
            updateFunction: (reviews = []) => reviews.map(review => 
                review.id === reviewId ? {
                    ...review,
                    votes: {
                        up: review.votes.up + (isUpvote ? 1 : 0),
                        down: review.votes.down + (isUpvote ? 0 : 1)
                    },
                    voters: { ...review.voters, [clientId]: true }
                } : review
            )
        });
        this.updateReviewList();
    }

    deleteReview(reviewId) {
        this.room.store.update({
            id: 'reviews',
            dependencies: { reviewId },
            updateFunction: (reviews = []) => reviews.filter(r => r.id !== reviewId)
        });
        this.updateReviewList();
    }

    setupPlayerCount() {
        document.getElementById('playerCountNum').textContent = '1';
        this.room.onPeersChanged = (peers) => {
            document.getElementById('playerCountNum').textContent = Object.keys(peers).length;
        };
    }

    createSafeAudio(src) {
        try {
            const audio = new Audio(src);
            audio.onerror = (e) => {
                console.warn(`Audio file ${src} failed to load:`, e);
            };
            return audio;
        } catch (e) {
            console.warn(`Failed to create audio for ${src}:`, e);
            return {
                play: () => {}
            };
        }
    }

    setupEventListeners() {
        let lastClick = 0;
        this.gameBoard.addEventListener('click', (e) => {
            const now = Date.now();
            if (now - lastClick < 300) { // Double click detected
                const clickX = e.clientX - this.gameBoard.getBoundingClientRect().left;
                const clickY = e.clientY - this.gameBoard.getBoundingClientRect().top;
                
                const clickedTower = this.towers.find(tower => {
                    const dx = tower.x - clickX;
                    const dy = tower.y - clickY;
                    return Math.sqrt(dx * dx + dy * dy) < 20;
                });

                if (clickedTower) {
                    const towerCosts = {
                        basic: 100,
                        sniper: 200,
                        crystal: 300,
                        tesla: 650,
                        flame: 350,
                        missile: 800,
                        ice: 300,
                        poison: 500
                    };
                    
                    const refund = Math.floor(towerCosts[clickedTower.type] * 0.8);
                    this.money += refund;
                    this.updateResources();
                    
                    const idx = this.towers.indexOf(clickedTower);
                    this.towers.splice(idx, 1);
                    this.removeElementSafely(this.gameBoard, clickedTower.element);
                }
            }
            lastClick = now;

            const rect = this.gameBoard.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (this.selectedTowerType) {
                this.placeTower(x, y);
                
                if (!e.shiftKey) {
                    this.selectedTowerType = null;
                }
            }
        });

        document.querySelectorAll('.tower-option').forEach(option => {
            option.addEventListener('click', () => {
                const cost = parseInt(option.dataset.cost);
                if (this.money >= cost) {
                    this.selectedTowerType = option.dataset.type;
                    this.showRangeIndicator(option.dataset.x, option.dataset.y, this.getTowerRange(this.selectedTowerType));
                    option.dataset.tooltip = this.getTowerTooltip(this.selectedTowerType);
                }
            });
        });

        document.getElementById('glossaryButton').addEventListener('click', () => {
            this.toggleGlossary();
        });

        document.querySelector('#glossary .close-button').addEventListener('click', () => {
            document.getElementById('glossary').style.display = 'none';
        });

        document.getElementById('changelogButton').addEventListener('click', () => {
            this.toggleChangelog();
        });

        document.querySelector('#changelog .close-button').addEventListener('click', () => {
            document.getElementById('changelog').style.display = 'none';
        });

        document.getElementById('pauseButton').addEventListener('click', () => {
            this.paused = !this.paused;
            document.getElementById('pauseButton').textContent = this.paused ? 'Resume' : 'Pause';
        });

        document.getElementById('restartButton').addEventListener('click', () => {
            if(confirm('Really restart game?')) {
                location.reload();
            }
        });

        document.getElementById('debugButton').addEventListener('click', () => {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });

        document.getElementById('skipWaveBtn').addEventListener('click', () => {
            if (this.waveInProgress) {
                this.zombies.forEach(zombie => {
                    this.removeElementSafely(this.gameBoard, zombie.element);
                });
                this.zombies = [];
                this.zombiesSpawned = this.zombiesInWave;
                this.waveInProgress = false;
            }
        });

        document.getElementById('fastForwardBtn').addEventListener('click', () => {
            if (this.waveInProgress && this.zombiesSpawned < this.zombiesInWave) {
                const remaining = this.zombiesInWave - this.zombiesSpawned;
                for (let i = 0; i < remaining; i++) {
                    this.fastForwardedCount++;
                    this.spawnZombie(true); 
                    this.zombiesSpawned++;
                }
            }
        });

        document.getElementById('addMoneyBtn').addEventListener('click', () => {
            this.money += 50000;
            this.updateResources();
        });

        document.getElementById('godModeBtn').addEventListener('click', () => {
            this.godMode = !this.godMode;
            document.getElementById('godModeBtn').textContent = `God Mode: ${this.godMode ? 'ON' : 'OFF'}`;
        });
    }

    toggleGlossary() {
        const glossary = document.getElementById('glossary');
        if (glossary.style.display === 'none' || !glossary.style.display) {
            this.updateGlossary();
            glossary.style.display = 'block';
        } else {
            glossary.style.display = 'none';
        }
    }

    toggleChangelog() {
        const changelog = document.getElementById('changelog');
        if (changelog.style.display === 'none' || !changelog.style.display) {
            changelog.style.display = 'block';
        } else {
            changelog.style.display = 'none';
        }
    }

    getTowerTooltip(type) {
        const names = {
            basic: "Basic Tower",
            sniper: "Sniper Tower",
            crystal: "Crystal Shard Tower", 
            tesla: "Tesla Tower",
            flame: "Flame Tower",
            missile: "Missile Silo Tower",
            ice: "Ice Tower",
            poison: "Poison Tower",
        };
        return names[type];
    }

    updateGlossary() {
        const content = document.getElementById('glossaryContent');
        content.innerHTML = '';
        
        Object.keys(this.zombieKills).forEach(type => {
            const entry = document.createElement('div');
            entry.className = 'zombie-entry';
            
            entry.innerHTML = `
                <div class="zombie-icon" style="color: ${this.getZombieColor(type)}"></div>
                <div class="zombie-details">
                    <h3>${this.zombieInfo[type].name}</h3>
                    <p>Kills: ${this.zombieKills[type]}</p>
                    <p>${this.zombieInfo[type].description}</p>
                    <p>Health: ${this.zombieInfo[type].health} | Speed: ${this.zombieInfo[type].speed}</p>
                    <p>Special: ${this.zombieInfo[type].special}</p>
                </div>
            `;
            
            content.appendChild(entry);
        });
    }

    placeTower(x, y) {
        const towerCosts = {
            basic: 100,
            sniper: 200,
            crystal: 300,
            tesla: 650,
            flame: 350,
            missile: 800,
            ice: 300,
            poison: 500,
        };

        if (this.money >= towerCosts[this.selectedTowerType]) {
            const tower = document.createElement('div');
            tower.className = 'tower';
            tower.style.left = x + 'px';
            tower.style.top = y + 'px';
            tower.style.color = this.getTowerColor(this.selectedTowerType);
            tower.dataset.tooltip = this.getTowerTooltip(this.selectedTowerType);
            this.gameBoard.appendChild(tower);
            
            this.towers.push({
                element: tower,
                type: this.selectedTowerType,
                x: x,
                y: y,
                lastShot: 0,
                range: this.getTowerRange(this.selectedTowerType)
            });

            this.money -= towerCosts[this.selectedTowerType];
            this.updateResources();
            this.selectedTowerType = null;
        }
    }

    removeElementSafely(parent, child) {
        try {
            if (child && child.parentNode === parent) {
                parent.removeChild(child);
            }
        } catch (e) {
            console.warn('Failed to remove element:', e);
        }
    }

    getTowerColor(type) {
        const colors = {
            basic: '#aaa',
            sniper: '#44f',
            crystal: '#aaf',
            tesla: '#ff0',
            flame: '#f80',
            missile: '#f44',
            ice: '#0ff',
            poison: '#0f0',
        };
        return colors[type];
    }

    getTowerRange(type) {
        const ranges = {
            basic: 180,
            sniper: 300,
            crystal: 120,
            tesla: 140,
            flame: 80,
            missile: 200,
            ice: 120,
            poison: 150,
        };
        return ranges[type];
    }
    
    showRangeIndicator(x, y, range) {
        const existingIndicators = document.querySelectorAll('.range-indicator');
        existingIndicators.forEach(indicator => indicator.remove());

        const indicator = document.createElement('div');
        indicator.className = 'range-indicator';
        indicator.style.width = (range * 2) + 'px';
        indicator.style.height = (range * 2) + 'px';
        
        if (this.selectedTowerType === 'missile') {
            indicator.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
            indicator.style.border = '2px solid rgba(255, 0, 0, 0.3)';
        }
        
        const updatePosition = (e) => {
            const rect = this.gameBoard.getBoundingClientRect();
            indicator.style.left = (e.clientX - rect.left) + 'px';
            indicator.style.top = (e.clientY - rect.top) + 'px';
        };
        
        this.gameBoard.addEventListener('mousemove', updatePosition);
        this.gameBoard.addEventListener('click', () => {
            indicator.remove();
            this.gameBoard.removeEventListener('mousemove', updatePosition);
        }, { once: true });
        
        this.gameBoard.appendChild(indicator);
    }

    spawnZombie(isFastForwarded = false) {
        const wave = this.wave;
        const roll = Math.random();
        let type;

        if (wave < 3) {
            type = roll < 0.8 ? 'normal' : 'fast';
        } else if (wave < 5) {
            if (roll < 0.6) type = 'normal';
            else if (roll < 0.8) type = 'fast';
            else type = 'tank';
        } else if (wave < 8) {
            if (roll < 0.4) type = 'normal';
            else if (roll < 0.6) type = 'fast';
            else if (roll < 0.8) type = 'tank';
            else if (roll < 0.9) type = 'necromancer';
            else type = 'boss';
        } else if (wave < 40) {
            if (roll < 0.3) type = 'normal';
            else if (roll < 0.4) type = 'fast';
            else if (roll < 0.5) type = 'tank';
            else if (roll < 0.6) type = 'boss';
            else if (roll < 0.7) type = 'necromancer';
            else if (roll < 0.8) type = 'splitting';
            else if (roll < 0.9) type = 'teleporter';
            else if (roll < 0.95) type = 'absorber';
            else type = 'crystalline';
        }
        
        const healthMultiplier = isFastForwarded ? 1 + Math.min(0.15 * this.fastForwardedCount, 7.5 + (Math.max(0, this.fastForwardedCount - 50) * 0.01)) : 1;

        const baseHealth = this.getZombieHealth(type);

        if (type === 'necromancer' && this.zombies.some(z => z.type === 'necromancer')) {
            type = 'normal';
        }
        
        const zombie = document.createElement('div');
        zombie.className = 'zombie';
        zombie.dataset.type = type;
        zombie.dataset.tooltip = this.zombieInfo[type].name;

        const zombieData = {
            element: zombie,
            type: type,
            x: -30,
            y: Math.random() * this.gameBoard.clientHeight,
            health: baseHealth * healthMultiplier,
            maxHealth: baseHealth * healthMultiplier,
            speed: this.getZombieSpeed(type),
            shield: type === 'boss' ? 200 : 0,
            shieldedBy: null,
            statusEffects: {
                poison: 0,
                burning: 0,
                frozen: 0
            },
            isFastForwarded: isFastForwarded,
            resurrectionCount: 0 
        };

        const healthBar = document.createElement('div');
        healthBar.className = 'zombie-health-bar';
        const healthFill = document.createElement('div');
        healthFill.className = 'zombie-health-fill';
        healthBar.appendChild(healthFill);
        zombie.appendChild(healthBar);
        
        zombieData.maxHealth = zombieData.health;

        zombie.style.color = this.getZombieColor(type);
        this.gameBoard.appendChild(zombie);
        this.zombies.push(zombieData);
        
        if (Math.random() < 0.1 && this.zombieSounds[type]) {
            try {
                this.zombieSounds[type].play().catch(err => {
                    console.warn('Failed to play zombie sound:', err);
                });
            } catch (e) {
                console.warn('Error playing zombie sound:', e);
            }
        }
    }

    spawnZombieAt(type, x, y) {
        const zombie = document.createElement('div');
        zombie.className = 'zombie';
        zombie.dataset.type = type;
        zombie.dataset.tooltip = this.zombieInfo[type].name;

        const healthMultiplier = false ? 1 + (0.15 * this.fastForwardedCount) : 1;
        const baseHealth = this.getZombieHealth(type);
        
        const zombieData = {
            element: zombie,
            type: type,
            x: x,
            y: y,
            health: baseHealth * healthMultiplier,
            speed: this.getZombieSpeed(type),
            shield: type === 'boss' ? 200 : 0,
            shieldedBy: null,
            statusEffects: {
                poison: 0,
                burning: 0,
                frozen: 0
            }
        };

        const healthBar = document.createElement('div');
        healthBar.className = 'zombie-health-bar';
        const healthFill = document.createElement('div');
        healthFill.className = 'zombie-health-fill';
        healthBar.appendChild(healthFill);
        zombie.appendChild(healthBar);

        zombieData.maxHealth = zombieData.health;

        zombie.style.color = this.getZombieColor(type);
        this.gameBoard.appendChild(zombie);
        this.zombies.push(zombieData);
        
        if (Math.random() < 0.1 && this.zombieSounds[type]) {
            try {
                this.zombieSounds[type].play().catch(err => {
                    console.warn('Failed to play zombie sound:', err);
                });
            } catch (e) {
                console.warn('Error playing zombie sound:', e);
            }
        }
    }

    getZombieHealth(type) {
        const health = {
            normal: 100,
            fast: 75,
            tank: 300,
            boss: 1000,
            necromancer: 200,
            splitting: 150,
            teleporter: 120,
            absorber: 180,
            crystalline: 400,
        };
        return health[type];
    }

    getZombieSpeed(type) {
        const speed = {
            normal: 1,
            fast: 2,
            tank: 0.5,
            boss: 0.3,
            necromancer: 0.4,
            splitting: 1,
            teleporter: 1,
            absorber: 1,
            crystalline: 0.5,
        };
        return speed[type];
    }

    getZombieColor(type) {
        const colors = {
            normal: '#3f3',
            fast: '#ff0',
            tank: '#f44',
            boss: '#f0f',
            necromancer: '#7f7',
            splitting: '#fa0',
            teleporter: '#0ff',
            absorber: '#f7f',
            crystalline: '#fff',
        };
        return colors[type];
    }

    updateZombies(deltaTime) {
        this.zombies.forEach((zombie, index) => {
            zombie.x += zombie.speed;
            zombie.element.style.left = zombie.x + 'px';
            zombie.element.style.top = zombie.y + 'px';

            zombie.element.style.boxShadow = 'none';
            zombie.shieldedBy = null;

            if (zombie.type !== 'boss') {
                this.zombies.forEach(possibleBoss => {
                    if (possibleBoss.type === 'boss' && possibleBoss.shield > 0) {
                        const dx = possibleBoss.x - zombie.x;
                        const dy = possibleBoss.y - zombie.y;
                        if (Math.sqrt(dx * dx + dy * dy) < 140) {
                            zombie.element.style.boxShadow = '0 0 20px rgba(255,0,255,0.5)';
                            zombie.shieldedBy = possibleBoss;
                        }
                    }
                });
            }

            if (zombie.type === 'necromancer') {
                if (!zombie.resurrectionCount) {
                    zombie.resurrectionCount = 0;
                }

                if (zombie.resurrectionCount < 10) {
                    const nearbyDead = this.recentlyDeadZombies.filter(dead => {
                        const dx = dead.x - zombie.x;
                        const dy = dead.y - zombie.y;
                        return Math.sqrt(dx * dx + dy * dy) < 150 && 
                               dead.type !== 'necromancer' && 
                               dead.type !== 'splitting';
                    });
                    
                    if (nearbyDead.length > 0) {
                        zombie.resurrectionCount++;
                        const resurrected = nearbyDead[Math.floor(Math.random() * nearbyDead.length)];
                        this.spawnZombieAt(resurrected.type, resurrected.x, resurrected.y);
                        const idx = this.recentlyDeadZombies.indexOf(resurrected);
                        this.recentlyDeadZombies.splice(idx, 1);

                        if (zombie.resurrectionCount === 10) {
                            zombie.speed *= 1.5; 
                        }
                    }
                }
            }

            this.applyStatusEffects(zombie);

            if (zombie.x > this.gameBoard.clientWidth) {
                this.removeElementSafely(this.gameBoard, zombie.element);
                this.zombies.splice(index, 1);
                if (!this.godMode) {
                    this.health -= 10;
                    if (this.health <= 0) {
                        this.gameOver();
                    }
                }
                this.updateResources();
            }

            const healthBar = zombie.element.querySelector('.zombie-health-fill');
            if (healthBar) {
                healthBar.style.width = (zombie.health / zombie.maxHealth * 100) + '%';
            }
        });
    }

    applyStatusEffects(zombie) {
        if (!zombie.statusEffects) {
            zombie.statusEffects = {
                poison: 0,
                burning: 0,
                frozen: 0
            };
        }

        if (zombie.statusEffects.poison > 0) {
            zombie.health -= 8; 
            zombie.statusEffects.poison -= 100; 
            const counter = zombie.element.querySelector('.poison-counter');
            if (counter) {
                counter.textContent = Math.ceil(zombie.statusEffects.poison / 1000);
            }
        }

        if (zombie.statusEffects.burning > 0) {
            zombie.health -= 5; 
            zombie.statusEffects.burning -= 100; 
        }

        if (zombie.statusEffects.frozen > 0) {
            zombie.statusEffects.frozen -= 100; 
            if (zombie.statusEffects.frozen <= 0) {
                zombie.speed *= 2; 
            }
        }
    }

    updateTowers(deltaTime) {
        this.towers.forEach(tower => {
            if (Date.now() - tower.lastShot > this.getTowerCooldown(tower.type)) {
                const target = this.findTarget(tower);
                if (target) {
                    this.shoot(tower, target);
                    tower.lastShot = Date.now();
                }
            }
        });
    }

    getTowerCooldown(type) {
        const cooldowns = {
            basic: 1000,
            sniper: 2000,
            crystal: 1500,
            tesla: 800,
            flame: 200,
            missile: 4800,
            ice: 1000,
            poison: 1000,
        };
        return cooldowns[type];
    }

    findTarget(tower) {
        if (tower.type === 'missile') {
            return this.zombies.find(zombie => {
                const dx = zombie.x - tower.x;
                const dy = zombie.y - tower.y;
                return Math.sqrt(dx * dx + dy * dy) > tower.range;
            });
        }

        if (tower.type === 'sniper') {
            return this.zombies.reduce((highest, zombie) => {
                const dx = zombie.x - tower.x;
                const dy = zombie.y - tower.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= tower.range) {
                    return (!highest || zombie.health > highest.health) ? zombie : highest;
                }
                return highest;
            }, null);
        }
        
        if (tower.type === 'basic') {
            let closestZombie = null;
            let closestDistance = tower.range;

            this.zombies.forEach(zombie => {
                const dx = zombie.x - tower.x;
                const dy = zombie.y - tower.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= tower.range && (!closestZombie || zombie.x > closestZombie.x)) {
                    closestZombie = zombie;
                    closestDistance = distance;
                }
            });
            
            return closestZombie;
        }

        const nonGhostZombies = this.zombies.filter(z => 
            z.type !== 'ghost' || 
            !this.zombies.some(other => 
                other !== z && 
                other.type !== 'ghost' && 
                Math.hypot(other.x - tower.x, other.y - tower.y) < tower.range
            )
        );
        
        return nonGhostZombies.find(zombie => {
            const dx = zombie.x - tower.x;
            const dy = zombie.y - tower.y;
            return Math.sqrt(dx * dx + dy * dy) < tower.range;
        });
    }

    shoot(tower, target) {
        if (tower.type === 'missile') {
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.dataset.type = 'missile';
            projectile.style.left = tower.x + 'px';
            projectile.style.top = tower.y + 'px';
            this.gameBoard.appendChild(projectile);
            
            this.projectiles.push({
                element: projectile,
                x: tower.x,
                y: tower.y,
                target: target,
                type: 'missile',
                speed: 5
            });
            return;
        }
        
        if (tower.type === 'crystal') {
            for (let i = 0; i < 5; i++) {
                const shard = document.createElement('div');
                shard.className = 'projectile crystal-shard';
                shard.style.left = tower.x + 'px';
                shard.style.top = tower.y + 'px';
                this.gameBoard.appendChild(shard);

                const spread = (i - 2) * 15; // -30, -15, 0, 15, 30 degrees
                this.projectiles.push({
                    element: shard,
                    x: tower.x,
                    y: tower.y,
                    target: target,
                    type: 'crystal',
                    speed: 8,
                    spreadAngle: spread,
                    noHoming: true
                });
            }
            return;
        }

        const projectile = document.createElement('div');
        projectile.className = 'projectile';
        
        projectile.style.left = tower.x + 'px';
        projectile.style.top = tower.y + 'px';
        
        this.gameBoard.appendChild(projectile);

        this.projectiles.push({
            element: projectile,
            x: tower.x,
            y: tower.y,
            target: target,
            type: tower.type,
            speed: tower.type === 'laser' ? 15 : 5,
            pierceCount: tower.type === 'laser' ? 0 : undefined,
            originTower: tower,
            damage: tower.type === 'laser' ? 125 : undefined
        });
    }

    updateProjectiles(deltaTime) {
        this.projectiles = this.projectiles.filter((projectile, index) => {
            if (projectile.type === 'hex') {
                if (!projectile.target || !this.zombies.includes(projectile.target)) {
                    const newTarget = this.findNearestZombieToProjectile(projectile);
                    if (!newTarget || projectile.pierceCount >= 5) {
                        this.removeElementSafely(this.gameBoard, projectile.element);
                        return false;
                    }
                    projectile.target = newTarget;
                }

                const dx = projectile.target.x - projectile.x;
                const dy = projectile.target.y - projectile.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 10) {
                    if (this.hitTarget(projectile.target, projectile.type, projectile)) {
                        return true;
                    }
                    this.removeElementSafely(this.gameBoard, projectile.element);
                    return false;
                }

                projectile.x += (dx / dist) * 15;
                projectile.y += (dy / dist) * 15;
                projectile.element.style.left = projectile.x + 'px';
                projectile.element.style.top = projectile.y + 'px';
                
                projectile.element.style.transform = `translate(-50%, -50%) rotate(${projectile.x * 0.1}deg)`;
                
                return true;
            } else {
                const dx = projectile.target.x - projectile.x;
                const dy = projectile.target.y - projectile.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 10) {
                    this.hitTarget(projectile.target, projectile.type);
                    this.removeElementSafely(this.gameBoard, projectile.element);
                    return false;
                }

                if (projectile.type === 'crystal' && projectile.spreadAngle !== undefined) {
                    const angle = Math.atan2(dy, dx) + (projectile.spreadAngle * Math.PI / 180);
                    projectile.x += Math.cos(angle) * projectile.speed;
                    projectile.y += Math.sin(angle) * projectile.speed;
                } else {
                    projectile.x += (dx / dist) * projectile.speed;
                    projectile.y += (dy / dist) * projectile.speed;
                }
                
                projectile.element.style.left = projectile.x + 'px';
                projectile.element.style.top = projectile.y + 'px';
                
                return true;
            }
        });
    }

    findNearestZombieToProjectile(projectile) {
        return this.zombies.reduce((nearest, zombie) => {
            if (projectile.hitTargets && projectile.hitTargets.includes(zombie)) {
                return nearest;
            }

            const dx = zombie.x - projectile.x;
            const dy = zombie.y - projectile.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (!nearest || dist < nearest.dist) {
                return { zombie, dist };
            }
            return nearest;
        }, null)?.zombie;
    }

    hitTarget(zombie, towerType, projectile) {
        // Add check at the start to prevent hitting already-dead zombies
        if (!this.zombies.includes(zombie)) {
            return false;
        }

        switch(towerType) {
            case 'ice':
                // Only target if not already frozen
                if (!zombie.statusEffects.frozen) {
                    zombie.statusEffects.frozen = 4000; 
                    zombie.speed *= 0.5;  
                }
                break;
            case 'poison':
                zombie.statusEffects.poison = Math.min((zombie.statusEffects.poison || 0) + 3000, 6000);
                const puddle = document.createElement('div');
                puddle.className = 'effect-indicator poison-indicator';
                puddle.style.width = '84px';
                puddle.style.height = '84px';
                puddle.style.left = (zombie.x - 42) + 'px';
                puddle.style.top = (zombie.y - 42) + 'px';
                puddle.dataset.zombieId = zombie.id;
                this.gameBoard.appendChild(puddle);
                setTimeout(() => this.removeElementSafely(this.gameBoard, puddle), 3000);
                
                // Apply initial poison damage
                zombie.health -= 8; // Initial poison damage
                break;
            case 'tesla':
                const chainTargets = this.zombies.filter(z => {
                    if (z === zombie) return false;
                    const dx = z.x - zombie.x;
                    const dy = z.y - zombie.y;
                    return Math.sqrt(dx * dx + dy * dy) < 140;  
                }).slice(0, 3);
                
                chainTargets.forEach(target => {
                    const chainDamage = target.isFastForwarded ? 10 : 20;
                    target.health -= chainDamage;

                    // Create lightning bolt container
                    const bolt = document.createElement('div');
                    bolt.className = 'lightning-bolt';
                    
                    // Create shadow elements
                    const shadow1 = document.createElement('div');
                    shadow1.className = 'lightning-shadow';
                    const shadow2 = document.createElement('div');
                    shadow2.className = 'lightning-shadow';
                    
                    // Create core lightning
                    const core = document.createElement('div');
                    core.className = 'lightning-core';
                    
                    // Add elements to bolt
                    bolt.appendChild(shadow1);
                    bolt.appendChild(shadow2);
                    bolt.appendChild(core);
                    
                    // Position and rotate the bolt
                    const dx = target.x - zombie.x;
                    const dy = target.y - zombie.y;
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    bolt.style.left = zombie.x + 'px';
                    bolt.style.top = zombie.y + 'px';
                    bolt.style.width = length + 'px';
                    bolt.style.transform = `rotate(${angle}deg)`;
                    
                    this.gameBoard.appendChild(bolt);
                    setTimeout(() => this.removeElementSafely(this.gameBoard, bolt), 200);
                });
                break;
        }

        if (zombie.shieldedBy) {
            zombie.shieldedBy.shield -= 20;
            if (zombie.shieldedBy.shield <= 0) {
                zombie.shieldedBy = null;
            }
            return false;
        }

        let damage = {
            basic: 45,
            sniper: 112.5,
            crystal: 60,
            tesla: zombie.isFastForwarded ? 20 : 40,
            flame: 15,
            missile: 180,
            ice: 20,
            poison: 30,
        }[towerType] || 45;

        if (zombie.isFastForwarded) {
            damage *= 0.5;
        }

        zombie.health -= damage;

        if (zombie.health <= 0 && this.zombies.includes(zombie)) {  // Add validation check
            this.zombieKills[zombie.type]++;
            this.recentlyDeadZombies.push({
                type: zombie.type,
                x: zombie.x,
                y: zombie.y
            });

            if (zombie.type === 'splitting') {
                for (let i = 0; i < 2; i++) {
                    this.spawnRandomZombie(zombie.x, zombie.y);
                }
            }

            this.removeElementSafely(this.gameBoard, zombie.element);
            const index = this.zombies.indexOf(zombie);
            if (index > -1) {
                this.zombies.splice(index, 1);
            }
            
            this.money += 25;
            this.updateResources();

            const indicators = document.querySelectorAll(`.effect-indicator[data-zombie-id="${zombie.id}"]`);
            indicators.forEach(indicator => this.removeElementSafely(this.gameBoard, indicator));
        }

        return false;
    }

    gameLoop() {
        const now = Date.now();
        const deltaTime = this.paused ? 0 : now - this.lastUpdate;
        this.lastUpdate = this.paused ? this.lastUpdate : now;

        if (!this.paused) {
            if (!this.waveInProgress && this.zombies.length === 0) {
                this.startNewWave();
            }

            if (this.waveInProgress) {
                this.spawnZombieTimer += deltaTime;
                const spawnDelay = Math.max(500, 2000 - (this.zombiesInWave * 10));
                if (this.spawnZombieTimer > spawnDelay && this.zombiesSpawned < this.zombiesInWave) {
                    this.spawnZombie();
                    this.zombiesSpawned++;
                    this.spawnZombieTimer = 0;
                }

                if (this.zombiesSpawned >= this.zombiesInWave && this.zombies.length === 0) {
                    this.waveInProgress = false;
                }
            }

            this.updateZombies(deltaTime);
            this.updateTowers(deltaTime);
            this.updateProjectiles(deltaTime);
        }

        requestAnimationFrame(() => this.gameLoop());
    }

    startNewWave() {
        this.wave++;
        this.fastForwardedCount = 0; 
        if (this.wave === 40) {
            this.spawnMeteorBoss();
            return;
        }
        if (this.wave > 40) {
            this.victory();
            return;
        }
        this.zombiesInWave = Math.floor(10 + (this.wave * 2));
        this.zombiesSpawned = 0;
        this.waveInProgress = true;
        this.updateResources();
    }

    spawnMeteorBoss() {
        const boss = document.createElement('div');
        boss.className = 'zombie meteor-boss';
        boss.dataset.type = 'meteor';
        boss.dataset.tooltip = this.zombieInfo.meteor.name;

        const bossData = {
            element: boss,
            type: 'meteor',
            x: this.gameBoard.clientWidth / 2,
            y: -50,
            health: 400000,
            speed: 0.5,
            lastMeteorAttack: 0,
            meteorCooldown: 5000
        };

        this.gameBoard.appendChild(boss);
        this.zombies.push(bossData);
    }

    gameOver() {
        alert('Game Over! You survived ' + (this.wave - 1) + ' waves!');
        location.reload();
    }

    victory() {
        if (!localStorage.getItem('hasBeatBoss')) {
            this.room.store.update({
                id: 'playerStats',
                dependencies: {},
                updateFunction: (stats) => ({
                    ...stats,
                    bossDefeats: stats.bossDefeats + 1
                })
            });
            localStorage.setItem('hasBeatBoss', 'true');
        }
        for (let i = 0; i < 100; i++) {
            setTimeout(() => {
                const confetti = document.createElement('div');
                confetti.className = 'victory-confetti';
                confetti.style.left = Math.random() * window.innerWidth + 'px';
                confetti.style.top = '-10px';
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                document.body.appendChild(confetti);

                setTimeout(() => confetti.remove(), 3000);
            }, i * 50);
        }

        alert('Congratulations! You\'ve completed all 40 waves!');
        location.reload();
    }

    findNearestTower(zombie) {
        return this.towers.find(tower => {
            const dx = tower.x - zombie.x;
            const dy = tower.y - zombie.y;
            return Math.sqrt(dx * dx + dy * dy) < 100;
        });
    }

    destroyTower(tower) {
        this.removeElementSafely(this.gameBoard, tower.element);
        const index = this.towers.indexOf(tower);
        if (index > -1) {
            this.towers.splice(index, 1);
        }
    }

    spawnRandomZombie(x, y) {
        const restrictedTypes = ['necromancer', 'absorber', 'meteor', 'splitting'];
        let availableTypes = this.zombieTypes.filter(type => !restrictedTypes.includes(type));
        let randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        this.spawnZombieAt(randomType, x, y);
    }
}

const game = new Game();
</script></body></html>